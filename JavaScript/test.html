<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Artificial Intelligence Puzzle</title>
    <script src="https://ajax.googleapis.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
    <link rel="stylesheet" href="//netdna.bootstrapcdn.com/bootstrap/4.0.0/css/bootstrap.min.css">
    <link rel="stylesheet" href="https://ajax.googleapis.com/ajax/libs/jqueryui/1.12.1/themes/base/jquery-ui.css">
    <link href="https://use.fontawesome.com/releases/v5.0.8/css/all.css" rel="stylesheet">
    <link type="text/css" rel="stylesheet" href="assets/css/style.css" />
</head>
<body>

<section id="game">
    <div class="container pt-5 pb-5">
        <div class="row">
            <div class="col-12">
                <h1><small class="fa fa-heart"></small> <em>Artificial Intelligence</em> <strong>Puzzle</strong></h1>
                <p>Pau Sanchez Valdivieso - <a href="https://www.pausanchezv.com" target="_blank">www.pausanchezv.com</a></p>
            </div>
            <div id="left-state" class="col-lg-7 col-md-12 mt-4">
                <div class="transparent large-shadow">
                    <p>Click the button to start enjoying!</p>
                </div>
                <h3><strong><em>Start State</em></strong></h3>
                <ul>
                    <li data-color="B"></li>
                    <li data-color="R"></li>
                    <li data-color="G"></li>
                    <li data-color="B"></li>
                    <li data-color="#"></li>
                    <div class="clear"></div>
                    <li data-color="#"></li>
                    <li data-color="#"></li>
                    <li data-color="#"></li>
                    <li data-color="B"></li>
                    <li data-color="#"></li>
                    <div class="clear"></div>
                    <li data-color="#"></li>
                    <li data-color="G"></li>
                    <li data-color="G"></li>
                    <li data-color="Y"></li>
                    <li data-color="R"></li>
                    <div class="clear"></div>
                    <li data-color="#"></li>
                    <li data-color="R"></li>
                    <li data-color="R"></li>
                    <li data-color="B"></li>
                    <li data-color="Y"></li>
                </ul>
            </div>
            <div id="right-state" class="col-lg-5 col-md-12 display mt-4">
                <h3><strong><em>Goal State</em></strong></h3>
                <ul></ul>
                <h3 id="moves-left" class="moves-left display mt-4">A-Star moves: <strong></strong></h3>
                <h4 id="solve-text" class="display mt-2"><strong>Click the button to solve the puzzle!</strong></h4>
                <h4 id="generate-text" class="display mt-5"><strong>Click the button to generate a puzzle!</strong></h4>
            </div>
        </div>
        <div class="clear"></div>
        <div class="mt-5">
            <a id="generate-level" class="btn mt-1 btn-primary large-shadow">Generate a  random puzzle</a>
            <a id="level-solver" class="btn mt-5 ml-3 btn-danger large-shadow display">Solve the puzzle</a>
        </div>
    </div>
</section>

<section id="author">
    <div class="container pt-5">
        <div class="row">
            <div class="col-12">
                <h2 class="mb-3">Game rules</h2>
                <p>The objective involves getting the goal state color starting from the start state by using the allowed movements.</p>
                <p>When a square is moved all its content is also moved, so that the start square will be changed with the destination square.</p>
                <p>The movement is governed by the square which starts the movement, so that the destination square will have to change its position even if its figure cannot make that move.</p>
                <p>Both squares, start and destination will be able to do the movements of their figures in their new positions on the matrix.</p>
                <p>Keep in mind that in the goal state doesn't matter the position of the figures. It's only important to get the matrix goal color.</p>
            </div>
            <div class="col-12 mt-4">
                <h2 class="mb-3">Figures</h2>
                <p><strong>Towers</strong> can be moved perpendicular</p>
                <p><strong>Bishops</strong> can be moved diagonally</p>
                <p><strong>Queens</strong> can be moved in all directions</p>
                <p>The number on the squares represents the <strong>movement scope allowed</strong></p>
                <p></p>
            </div>
            <div class="col-12 mt-4">
                <h2 class="mb-3">A-Star & Heuristic</h2>
                <p>Since the problem we are trying to solve is absolutely NP-HARD, we have to get an approximate solution because if we need a fast algorithm, then cannot spend much time expanding more nodes than the necessary ones.</p>
                <p>First of all I tried to get the best solution always, and I got it by using Backtracking techniques in the heuristic. But there is a problem: the heuristic is called for each node expansion, in our case, around 200 times for each expansion (it is brutally hard to solve). The backtracking was used to find the best square pairs which the distance among all of them was lower (it is another hard problem because you know what you want, but you have to explore all to find it).</p>
                <p>The truth is that it worked perfectly because the states were expanded following always the best path since the exhaustive search explores absolutely all the possibilities to select the best one. And it finds it! The problem was that even if including branch and bound techniques, the A* was not able to hold itself if the puzzle size was greater than 9-12 squares. I had imagined that it was going to happen, but anyway, it had to be tested to make me able to rest in peace.</p>
                <p>Finally a Greedy heuristic is used and it is really fast, so we can throw four distinct heuristics, then run four A* Search and finally choose the best solution. It is necessary to keep in mind that there are cases that for example, an heuristic based on the euclidean distance works better than the other one that uses manhattan distance, and so on... If in most cases the solutions found varies around [-2, +2] among themselves, so it's much possible that the best is one of them, and if it's not, then there is no problem because we are very close to the best solution.</p>
                <p>But even if we are using a greedy solution, there are some cases in which a good solution is extremely difficult to find, especially when the difficulty level is 'expert' and we are using puzzles 5x5, 6x5, 5x6 or 6x6 size. It's difficult to stop the algorithm if some solution is harder to be found. Setting a timer cannot be a good solution, so there is a limit depth on A* Search, then if more than 5000 states have been expanded and we still have no solution, a new puzzle is recomputed and the whole process starts yet again (It is true that the worst case involves that the A-Star overcomes 5000 states, then it is called once more time, and so on..., but it is not going to happen due to pure statistic). So the average time that an user has to wait for a level is around 0-5 seconds. It seems quite reasonable if we keep in mind the brutal problem we are dealing with.</p>
                <p>The conclusion is that, given that the heuristic is just a numerical value, we can have some different heuristics which return different values from different scales, so we cannot call different heuristics from the same A*, but we can call 4 distinct A*, compare 4 results and finally choose the best one.</p>
            </div>
            <div class="col-12 mt-4">
                <h2 class="mb-3">Level Generator</h2>
                <p>There are basically two models of generated levels. The first one is based on an absolutely random way.</p>
                <p>The first thing that we have to do to generate this kind of level is to obtain a valid distribution. A distribution is an object that contains the amount percentage of characters for the level. For example, it doesn't make sense generating a level that contains only bishops because it has no solution.</p>
                <p>Now we have to get a valid puzzle size, both number of rows and columns. It will be given depending on the difficulty which is passed through the instance of the object.</p>
                <p>After that it's necessary to obtain the colors of the puzzle. The number of the colors depends on the puzzle size obtained in the previous step.</p>
                <p>The next stage involves generating the level. First of all we generate the level as an array which will be used to build a graph in order to help us to check whether or not the level is connected. We can check the graph connection by using the Depth First Search Algorithm using it as a traversal algorithm instead of search algorithm. Then if the generated level has any isolated node, a recursive call is produced and this stage starts yet again until we get a valid level.</p>
                <p>As a result we have a puzzle array now, that is based on 3-positional items, first refers to kind of item (tower, bishop or queen), the second shows the scope of its move, an finally, third indicates the square color. Now, we are able to get the goal array which is based on the color. All we have to do is get it from the puzzle array catching just the third position for each item.</p>
                <p>Finally both puzzles start and goal are created using the arrays and depending on the puzzle size. The puzzles are saved in the levelGenerator object to extract the best solution by using the A* Search Algorithm. But that's another story which is explained in its section.</p>
                <p>The second kind of level is one where the start puzzle is constructed beforehand by a human, but the goal state is randomized starting from the first one.</p>
                <p>The first kind of level is better than the second one if we are looking for a level really difficult because the player doesn't have any strong visual model to keep in sight. On the other hand the second type of level is better than the first if we want a beautiful model, the realism decreases but it's easier to enjoy the level because you feel that you are building something that makes sense to see.</p>
                <p>The basic idea is to mix both kind of levels, random and half-random in order to obtain a final game hard and realistic by using the first level type, but kind of nice to look at, by using the second one.</p>
            </div>
            <div class="col-12 mt-4">
                <h2 class="mb-3">Animated Solver</h2>
                <p>An animated solver is needed to see that the A-Star algorithm is working correctly and it is not giving us any wrong sequence of actions.</p>
                <p>First of all we need to build the html of the matrix. It is closed under a UL tag, so our squares are constituted through LI tags.</p>
                <p>Every LI has several data attributes that are gonna help us to build the matrix as fast as possible. However these attributes won't useful to solve the problem since they are accessible through the browser console and it means that any user could hurt the application. And I don't want that! Instead, a closed JS Object is gonna manage the whole process.</p>
                <p>Things are tight when we have to do the variable change since the start square will have to be the goal square and so on... The easiest way to do that involves refilling the whole matrix because doing that is easier than to have to recompute all distances, all effects, all timers, that's not worth it!</p>
                <p>The next stage is easy, we just have to use the animate jQuery function to compute the square start effect, and then use its callback to compute the goal square effect.</p>
                <p>The point is how we will make the effects happen one after another. Easy! We just have to use the async foreach provided by jQuery and set a timer inside it. This is not the unique way, but it works well!</p>
            </div>
            <div class="col-12 mt-4 mb-5">
                <h2 class="mb-3">Who I am</h2>
                <p>My name is Pau and I am a Computer Engineer who loves programming and enjoys developing games, applications and algorithms. I got my degree at the University of Barcelona.</p>
                <p>I really like programming Artificial Intelligence algorithms finding the best solution for a given problem, I love developing applications and thinking that someone is gonna use them. I like to know that I am useful and I am able to contribute a little to improve anything.</p>
                <p>If I had to choose my favourite programming language, it would be Python due to its simplicity and particular syntax, however I love the other ones too. I feel something special for web development because when I was a child I used to develop websites and nowadays I am still doing it.</p>
                <p>I think developers have a special power, like Superman, he can fly through the sky, but we are able to imagine something and make it real. There are few people who are able to do that. It is one of the most wonderful sensations I have ever felt. All people have their strengths and abilities, but a programmer is a programmer.</p>
            </div>
        </div>
    </div>
</section>
</body>
</html>

<script>

    /**
     * Document ready function
     */
    $(document).ready(function(){

        // variables
        var level;
        var actions;
        var animatedSolver;

        // Get some generated level
        $("#generate-level").click(function() {

            $(".transparent > p").html('<i class="fas fa-spinner fa-spin"></i>');

            // DOM Actions
            $(this).hide();
            $("#level-solver").hide();
            $("#right-state").hide();
            $(".transparent").show();
            $("#generate-text").hide();

            setTimeout(function() {

                // Get the level from generator
                level = generateLevel();

                // Solver instance depending on both level and actions
                animatedSolver = new AnimatedSolver(level, actions);

                // Build the html
                animatedSolver.buildLevelHTML();
                animatedSolver.buildStartStateAnimation();

            },100);
        });

        // Solve the generated level
        $("#level-solver").click(function() {

            $(this).hide();
            $("#generate-level").hide();
            $("#solve-text").hide();

            // Solve the problem
            animatedSolver.animatedSolver();
        });

        // Generate level
        function generateLevel() {

            // TODO:: take out this motherfucker iteration
            for (var i = 0; i < 1; i++) {

                // Variables

                var problem;
                var canStop = false;

                // Dictionary that's gonna hold the four solutions given for the four heuristics
                var solutions = {
                    euclidean: [],
                    euclideanMatches: [],
                    manhattan: [],
                    manhattanMatches: []
                };

                // Level generator object
                var generator = new LevelGenerator('expert');

                // Repeat until at least one of heuristics returns a solution
                do {

                    // Generate a random level
                    level = generator.getGeneratedLevel(true);

                    // Get start and goal puzzles
                    start = level[0];
                    goal = level[1];

                    // Euclidean distances heuristic
                    console.time('A* Search using distancesHeuristic with euclidean');
                    problem = new SearchProblem(start, goal, SearchAlgorithms.AStarSearch, Heuristic.euclideanDistancesHeuristic);
                    problem.showResult();
                    solutions.euclidean = problem.getSolution();
                    console.timeEnd('A* Search using distancesHeuristic with euclidean');
                    console.log("");

                    if (solutions.euclidean.length > 0) {
                        canStop = true;
                    }

                    // Euclidean distances heuristic plus matches
                    console.time('A* Search using distancesHeuristic with euclidean M');
                    problem = new SearchProblem(start, goal, SearchAlgorithms.AStarSearch, Heuristic.euclideanDistancesHeuristicWithMatches);
                    problem.showResult();
                    solutions.euclideanMatches = problem.getSolution();
                    console.timeEnd('A* Search using distancesHeuristic with euclidean M');
                    console.log("");

                    if (solutions.euclideanMatches.length > 0) {
                        canStop = true;
                    }

                } while (!canStop);
            }

            actions = generator.getBestSolution(solutions);
            console.log("Best Solution Size: " + actions.length);
            return level;
        }
    });
</script>


<script src="https://ajax.googleapis.com/ajax/libs/jqueryui/1.12.1/jquery-ui.min.js"></script>
<script src="assets/js/binary-heap.js"></script>
<script src="assets/js/heuristic.js"></script>
<script src="assets/js/puzzle-classes.js"></script>
<script src="assets/js/search-algorithms.js"></script>
<script src="assets/js/level-generator.js"></script>
<script src="assets/js/animated-solver.js"></script>

